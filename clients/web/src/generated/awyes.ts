// @generated by protobuf-ts 2.9.4 with parameter long_type_string
// @generated from protobuf file "awyes.proto" (package "awyes", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Value } from "./google/protobuf/struct";
import { FieldDescriptorProto } from "./google/protobuf/descriptor";
/**
 * Handler definition
 *
 * @generated from protobuf message awyes.Handler
 */
export interface Handler {
    /**
     * @generated from protobuf field: optional string context = 1;
     */
    context?: string;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional int64 version = 3;
     */
    version?: string;
    /**
     * @generated from protobuf field: optional string description = 4;
     */
    description?: string;
    /**
     * @generated from protobuf field: repeated google.protobuf.FieldDescriptorProto parameters = 5;
     */
    parameters: FieldDescriptorProto[];
    /**
     * @generated from protobuf field: repeated google.protobuf.FieldDescriptorProto returns = 6;
     */
    returns: FieldDescriptorProto[];
}
/**
 * Position definition
 *
 * @generated from protobuf message awyes.Position
 */
export interface Position {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string description = 2;
     */
    description?: string;
    /**
     * @generated from protobuf field: optional string handler = 3;
     */
    handler?: string;
    /**
     * @generated from protobuf field: repeated awyes.Transition transition = 4;
     */
    transition: Transition[];
}
/**
 * Transition definition
 *
 * @generated from protobuf message awyes.Transition
 */
export interface Transition {
    /**
     * @generated from protobuf field: optional string label = 1;
     */
    label?: string;
    /**
     * @generated from protobuf field: optional string position = 2;
     */
    position?: string;
}
/**
 * Route definition
 *
 * @generated from protobuf message awyes.Route
 */
export interface Route {
    /**
     * @generated from protobuf field: optional string context = 1;
     */
    context?: string;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional int64 version = 3;
     */
    version?: string;
    /**
     * @generated from protobuf field: optional string description = 4;
     */
    description?: string;
    /**
     * @generated from protobuf field: repeated awyes.Position position = 5;
     */
    position: Position[];
    /**
     * @generated from protobuf field: repeated google.protobuf.FieldDescriptorProto parameter = 6;
     */
    parameter: FieldDescriptorProto[];
}
/**
 * Trip definition
 *
 * @generated from protobuf message awyes.Trip
 */
export interface Trip {
    /**
     * @generated from protobuf field: optional string id = 1;
     */
    id?: string;
    /**
     * @generated from protobuf field: optional awyes.Entity entity = 2;
     */
    entity?: Entity;
    /**
     * @generated from protobuf field: optional string route = 3;
     */
    route?: string;
    /**
     * @generated from protobuf field: optional int64 route_version = 4;
     */
    routeVersion?: string;
    /**
     * @generated from protobuf field: optional int64 started_at = 5;
     */
    startedAt?: string;
    /**
     * @generated from protobuf field: optional int64 completed_at = 6;
     */
    completedAt?: string;
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> state = 7;
     */
    state: {
        [key: string]: Value;
    };
}
/**
 * Entity definition
 *
 * @generated from protobuf message awyes.Entity
 */
export interface Entity {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional awyes.EntityType type = 2;
     */
    type?: EntityType;
}
/**
 * Event message for streaming execution updates
 *
 * @generated from protobuf message awyes.Event
 */
export interface Event {
    /**
     * @generated from protobuf field: optional string id = 1;
     */
    id?: string;
    /**
     * @generated from protobuf field: optional string trip = 2;
     */
    trip?: string;
    /**
     * @generated from protobuf field: optional int64 timestamp = 3;
     */
    timestamp?: string;
    /**
     * @generated from protobuf field: optional awyes.Status status = 4;
     */
    status?: Status;
    /**
     * @generated from protobuf field: optional awyes.Entity entity = 5;
     */
    entity?: Entity;
    /**
     * @generated from protobuf field: optional awyes.Position position = 6;
     */
    position?: Position;
    /**
     * @generated from protobuf field: optional string exit_label = 7;
     */
    exitLabel?: string;
    /**
     * @generated from protobuf field: optional string exit_message = 8;
     */
    exitMessage?: string;
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> state = 9;
     */
    state: {
        [key: string]: Value;
    };
}
/**
 * Event methods
 *
 * @generated from protobuf message awyes.ListEventsRequest
 */
export interface ListEventsRequest {
    /**
     * @generated from protobuf field: optional string trip = 1;
     */
    trip?: string;
}
/**
 * @generated from protobuf message awyes.ListEventsResponse
 */
export interface ListEventsResponse {
    /**
     * @generated from protobuf field: repeated awyes.Event events = 1;
     */
    events: Event[];
}
/**
 * Handlers methods
 *
 * @generated from protobuf message awyes.RegisterHandlerRequest
 */
export interface RegisterHandlerRequest {
    /**
     * @generated from protobuf field: optional awyes.Handler handler = 1;
     */
    handler?: Handler;
}
/**
 * @generated from protobuf message awyes.RegisterHandlerResponse
 */
export interface RegisterHandlerResponse {
    /**
     * @generated from protobuf field: optional awyes.Handler handler = 1;
     */
    handler?: Handler;
}
/**
 * @generated from protobuf message awyes.ListHandlersRequest
 */
export interface ListHandlersRequest {
}
/**
 * @generated from protobuf message awyes.ListHandlersResponse
 */
export interface ListHandlersResponse {
    /**
     * @generated from protobuf field: repeated awyes.Handler handlers = 1;
     */
    handlers: Handler[];
}
/**
 * @generated from protobuf message awyes.GetHandlerRequest
 */
export interface GetHandlerRequest {
    /**
     * @generated from protobuf field: optional string handler = 1;
     */
    handler?: string;
}
/**
 * @generated from protobuf message awyes.GetHandlerResponse
 */
export interface GetHandlerResponse {
    /**
     * @generated from protobuf field: optional awyes.Handler handler = 1;
     */
    handler?: Handler;
}
/**
 * Routes methods
 *
 * @generated from protobuf message awyes.RegisterRouteRequest
 */
export interface RegisterRouteRequest {
    /**
     * @generated from protobuf field: optional string route = 1;
     */
    route?: string;
}
/**
 * @generated from protobuf message awyes.RegisterRouteResponse
 */
export interface RegisterRouteResponse {
}
/**
 * @generated from protobuf message awyes.ListRoutesRequest
 */
export interface ListRoutesRequest {
}
/**
 * @generated from protobuf message awyes.ListRoutesResponse
 */
export interface ListRoutesResponse {
    /**
     * @generated from protobuf field: repeated awyes.Route routes = 1;
     */
    routes: Route[];
}
/**
 * @generated from protobuf message awyes.GetRouteRequest
 */
export interface GetRouteRequest {
    /**
     * @generated from protobuf field: optional string route = 1;
     */
    route?: string;
    /**
     * @generated from protobuf field: optional int64 version = 2;
     */
    version?: string;
}
/**
 * @generated from protobuf message awyes.GetRouteResponse
 */
export interface GetRouteResponse {
    /**
     * @generated from protobuf field: optional awyes.Route route = 1;
     */
    route?: Route;
}
/**
 * Trips methods
 *
 * @generated from protobuf message awyes.StartTripRequest
 */
export interface StartTripRequest {
    /**
     * @generated from protobuf field: optional awyes.Route route = 1;
     */
    route?: Route;
    /**
     * @generated from protobuf field: optional awyes.Entity entity = 2;
     */
    entity?: Entity;
    /**
     * @generated from protobuf field: optional awyes.Position start = 3;
     */
    start?: Position;
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> state = 4;
     */
    state: {
        [key: string]: Value;
    };
}
/**
 * @generated from protobuf message awyes.StartTripResponse
 */
export interface StartTripResponse {
    /**
     * @generated from protobuf field: optional awyes.Trip trip = 1;
     */
    trip?: Trip;
}
/**
 * @generated from protobuf message awyes.WatchTripRequest
 */
export interface WatchTripRequest {
    /**
     * @generated from protobuf field: optional string trip = 1;
     */
    trip?: string;
}
/**
 * @generated from protobuf message awyes.ListTripsRequest
 */
export interface ListTripsRequest {
    /**
     * @generated from protobuf field: optional awyes.Entity entity = 1;
     */
    entity?: Entity;
}
/**
 * @generated from protobuf message awyes.ListTripsResponse
 */
export interface ListTripsResponse {
    /**
     * @generated from protobuf field: repeated awyes.Trip trips = 1;
     */
    trips: Trip[];
}
/**
 * @generated from protobuf message awyes.GetTripRequest
 */
export interface GetTripRequest {
    /**
     * @generated from protobuf field: optional string trip = 1;
     */
    trip?: string;
}
/**
 * @generated from protobuf message awyes.GetTripResponse
 */
export interface GetTripResponse {
    /**
     * @generated from protobuf field: optional awyes.Trip trip = 1;
     */
    trip?: Trip;
}
/**
 * Search methods
 *
 * @generated from protobuf message awyes.SearchRequest
 */
export interface SearchRequest {
    /**
     * @generated from protobuf field: optional string query = 1;
     */
    query?: string;
}
/**
 * @generated from protobuf message awyes.SearchResponse
 */
export interface SearchResponse {
    /**
     * @generated from protobuf field: repeated awyes.Route routes = 1;
     */
    routes: Route[];
    /**
     * @generated from protobuf field: repeated awyes.Entity entities = 2;
     */
    entities: Entity[];
    /**
     * @generated from protobuf field: repeated awyes.Handler handlers = 3;
     */
    handlers: Handler[];
}
/**
 * @generated from protobuf enum awyes.EntityType
 */
export enum EntityType {
    /**
     * @generated from protobuf enum value: REPOSITORY = 0;
     */
    REPOSITORY = 0,
    /**
     * @generated from protobuf enum value: USER = 1;
     */
    USER = 1
}
/**
 * Status for events and trips
 *
 * @generated from protobuf enum awyes.Status
 */
export enum Status {
    /**
     * @generated from protobuf enum value: EXECUTING = 0;
     */
    EXECUTING = 0,
    /**
     * @generated from protobuf enum value: COMPLETED = 1;
     */
    COMPLETED = 1,
    /**
     * @generated from protobuf enum value: ERROR = 2;
     */
    ERROR = 2
}
/**
 * Labels for events and transitions
 *
 * @generated from protobuf enum awyes.Label
 */
export enum Label {
    /**
     * @generated from protobuf enum value: SUCCESS = 0;
     */
    SUCCESS = 0,
    /**
     * @generated from protobuf enum value: FAILURE = 1;
     */
    FAILURE = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class Handler$Type extends MessageType<Handler> {
    constructor() {
        super("awyes.Handler", [
            { no: 1, name: "context", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FieldDescriptorProto },
            { no: 6, name: "returns", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FieldDescriptorProto }
        ]);
    }
    create(value?: PartialMessage<Handler>): Handler {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parameters = [];
        message.returns = [];
        if (value !== undefined)
            reflectionMergePartial<Handler>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Handler): Handler {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string context */ 1:
                    message.context = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional int64 version */ 3:
                    message.version = reader.int64().toString();
                    break;
                case /* optional string description */ 4:
                    message.description = reader.string();
                    break;
                case /* repeated google.protobuf.FieldDescriptorProto parameters */ 5:
                    message.parameters.push(FieldDescriptorProto.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.FieldDescriptorProto returns */ 6:
                    message.returns.push(FieldDescriptorProto.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Handler, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string context = 1; */
        if (message.context !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.context);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional int64 version = 3; */
        if (message.version !== undefined)
            writer.tag(3, WireType.Varint).int64(message.version);
        /* optional string description = 4; */
        if (message.description !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* repeated google.protobuf.FieldDescriptorProto parameters = 5; */
        for (let i = 0; i < message.parameters.length; i++)
            FieldDescriptorProto.internalBinaryWrite(message.parameters[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.FieldDescriptorProto returns = 6; */
        for (let i = 0; i < message.returns.length; i++)
            FieldDescriptorProto.internalBinaryWrite(message.returns[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.Handler
 */
export const Handler = new Handler$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("awyes.Position", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "handler", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "transition", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Transition }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transition = [];
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string description */ 2:
                    message.description = reader.string();
                    break;
                case /* optional string handler */ 3:
                    message.handler = reader.string();
                    break;
                case /* repeated awyes.Transition transition */ 4:
                    message.transition.push(Transition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string description = 2; */
        if (message.description !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* optional string handler = 3; */
        if (message.handler !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.handler);
        /* repeated awyes.Transition transition = 4; */
        for (let i = 0; i < message.transition.length; i++)
            Transition.internalBinaryWrite(message.transition[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transition$Type extends MessageType<Transition> {
    constructor() {
        super("awyes.Transition", [
            { no: 1, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Transition>): Transition {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Transition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transition): Transition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string label */ 1:
                    message.label = reader.string();
                    break;
                case /* optional string position */ 2:
                    message.position = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string label = 1; */
        if (message.label !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* optional string position = 2; */
        if (message.position !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.position);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.Transition
 */
export const Transition = new Transition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Route$Type extends MessageType<Route> {
    constructor() {
        super("awyes.Route", [
            { no: 1, name: "context", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "position", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Position },
            { no: 6, name: "parameter", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FieldDescriptorProto }
        ]);
    }
    create(value?: PartialMessage<Route>): Route {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.position = [];
        message.parameter = [];
        if (value !== undefined)
            reflectionMergePartial<Route>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Route): Route {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string context */ 1:
                    message.context = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional int64 version */ 3:
                    message.version = reader.int64().toString();
                    break;
                case /* optional string description */ 4:
                    message.description = reader.string();
                    break;
                case /* repeated awyes.Position position */ 5:
                    message.position.push(Position.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.FieldDescriptorProto parameter */ 6:
                    message.parameter.push(FieldDescriptorProto.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Route, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string context = 1; */
        if (message.context !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.context);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional int64 version = 3; */
        if (message.version !== undefined)
            writer.tag(3, WireType.Varint).int64(message.version);
        /* optional string description = 4; */
        if (message.description !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* repeated awyes.Position position = 5; */
        for (let i = 0; i < message.position.length; i++)
            Position.internalBinaryWrite(message.position[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.FieldDescriptorProto parameter = 6; */
        for (let i = 0; i < message.parameter.length; i++)
            FieldDescriptorProto.internalBinaryWrite(message.parameter[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.Route
 */
export const Route = new Route$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Trip$Type extends MessageType<Trip> {
    constructor() {
        super("awyes.Trip", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity", kind: "message", T: () => Entity },
            { no: 3, name: "route", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "route_version", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "started_at", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "completed_at", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "state", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<Trip>): Trip {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = {};
        if (value !== undefined)
            reflectionMergePartial<Trip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Trip): Trip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional awyes.Entity entity */ 2:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* optional string route */ 3:
                    message.route = reader.string();
                    break;
                case /* optional int64 route_version */ 4:
                    message.routeVersion = reader.int64().toString();
                    break;
                case /* optional int64 started_at */ 5:
                    message.startedAt = reader.int64().toString();
                    break;
                case /* optional int64 completed_at */ 6:
                    message.completedAt = reader.int64().toString();
                    break;
                case /* map<string, google.protobuf.Value> state */ 7:
                    this.binaryReadMap7(message.state, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: Trip["state"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Trip["state"] | undefined, val: Trip["state"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field awyes.Trip.state");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: Trip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional awyes.Entity entity = 2; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional string route = 3; */
        if (message.route !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.route);
        /* optional int64 route_version = 4; */
        if (message.routeVersion !== undefined)
            writer.tag(4, WireType.Varint).int64(message.routeVersion);
        /* optional int64 started_at = 5; */
        if (message.startedAt !== undefined)
            writer.tag(5, WireType.Varint).int64(message.startedAt);
        /* optional int64 completed_at = 6; */
        if (message.completedAt !== undefined)
            writer.tag(6, WireType.Varint).int64(message.completedAt);
        /* map<string, google.protobuf.Value> state = 7; */
        for (let k of globalThis.Object.keys(message.state)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.state[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.Trip
 */
export const Trip = new Trip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Entity$Type extends MessageType<Entity> {
    constructor() {
        super("awyes.Entity", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", opt: true, T: () => ["awyes.EntityType", EntityType] }
        ]);
    }
    create(value?: PartialMessage<Entity>): Entity {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Entity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entity): Entity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional awyes.EntityType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Entity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional awyes.EntityType type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.Entity
 */
export const Entity = new Entity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super("awyes.Event", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "trip", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "status", kind: "enum", opt: true, T: () => ["awyes.Status", Status] },
            { no: 5, name: "entity", kind: "message", T: () => Entity },
            { no: 6, name: "position", kind: "message", T: () => Position },
            { no: 7, name: "exit_label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "exit_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "state", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<Event>): Event {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = {};
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string trip */ 2:
                    message.trip = reader.string();
                    break;
                case /* optional int64 timestamp */ 3:
                    message.timestamp = reader.int64().toString();
                    break;
                case /* optional awyes.Status status */ 4:
                    message.status = reader.int32();
                    break;
                case /* optional awyes.Entity entity */ 5:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* optional awyes.Position position */ 6:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional string exit_label */ 7:
                    message.exitLabel = reader.string();
                    break;
                case /* optional string exit_message */ 8:
                    message.exitMessage = reader.string();
                    break;
                case /* map<string, google.protobuf.Value> state */ 9:
                    this.binaryReadMap9(message.state, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: Event["state"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Event["state"] | undefined, val: Event["state"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field awyes.Event.state");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string trip = 2; */
        if (message.trip !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.trip);
        /* optional int64 timestamp = 3; */
        if (message.timestamp !== undefined)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        /* optional awyes.Status status = 4; */
        if (message.status !== undefined)
            writer.tag(4, WireType.Varint).int32(message.status);
        /* optional awyes.Entity entity = 5; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional awyes.Position position = 6; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional string exit_label = 7; */
        if (message.exitLabel !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.exitLabel);
        /* optional string exit_message = 8; */
        if (message.exitMessage !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.exitMessage);
        /* map<string, google.protobuf.Value> state = 9; */
        for (let k of globalThis.Object.keys(message.state)) {
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.state[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEventsRequest$Type extends MessageType<ListEventsRequest> {
    constructor() {
        super("awyes.ListEventsRequest", [
            { no: 1, name: "trip", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListEventsRequest>): ListEventsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEventsRequest): ListEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string trip */ 1:
                    message.trip = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string trip = 1; */
        if (message.trip !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.trip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.ListEventsRequest
 */
export const ListEventsRequest = new ListEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEventsResponse$Type extends MessageType<ListEventsResponse> {
    constructor() {
        super("awyes.ListEventsResponse", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<ListEventsResponse>): ListEventsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<ListEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEventsResponse): ListEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated awyes.Event events */ 1:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated awyes.Event events = 1; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.ListEventsResponse
 */
export const ListEventsResponse = new ListEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterHandlerRequest$Type extends MessageType<RegisterHandlerRequest> {
    constructor() {
        super("awyes.RegisterHandlerRequest", [
            { no: 1, name: "handler", kind: "message", T: () => Handler }
        ]);
    }
    create(value?: PartialMessage<RegisterHandlerRequest>): RegisterHandlerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterHandlerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterHandlerRequest): RegisterHandlerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional awyes.Handler handler */ 1:
                    message.handler = Handler.internalBinaryRead(reader, reader.uint32(), options, message.handler);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterHandlerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional awyes.Handler handler = 1; */
        if (message.handler)
            Handler.internalBinaryWrite(message.handler, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.RegisterHandlerRequest
 */
export const RegisterHandlerRequest = new RegisterHandlerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterHandlerResponse$Type extends MessageType<RegisterHandlerResponse> {
    constructor() {
        super("awyes.RegisterHandlerResponse", [
            { no: 1, name: "handler", kind: "message", T: () => Handler }
        ]);
    }
    create(value?: PartialMessage<RegisterHandlerResponse>): RegisterHandlerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterHandlerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterHandlerResponse): RegisterHandlerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional awyes.Handler handler */ 1:
                    message.handler = Handler.internalBinaryRead(reader, reader.uint32(), options, message.handler);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterHandlerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional awyes.Handler handler = 1; */
        if (message.handler)
            Handler.internalBinaryWrite(message.handler, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.RegisterHandlerResponse
 */
export const RegisterHandlerResponse = new RegisterHandlerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListHandlersRequest$Type extends MessageType<ListHandlersRequest> {
    constructor() {
        super("awyes.ListHandlersRequest", []);
    }
    create(value?: PartialMessage<ListHandlersRequest>): ListHandlersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListHandlersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListHandlersRequest): ListHandlersRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListHandlersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.ListHandlersRequest
 */
export const ListHandlersRequest = new ListHandlersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListHandlersResponse$Type extends MessageType<ListHandlersResponse> {
    constructor() {
        super("awyes.ListHandlersResponse", [
            { no: 1, name: "handlers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Handler }
        ]);
    }
    create(value?: PartialMessage<ListHandlersResponse>): ListHandlersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.handlers = [];
        if (value !== undefined)
            reflectionMergePartial<ListHandlersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListHandlersResponse): ListHandlersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated awyes.Handler handlers */ 1:
                    message.handlers.push(Handler.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListHandlersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated awyes.Handler handlers = 1; */
        for (let i = 0; i < message.handlers.length; i++)
            Handler.internalBinaryWrite(message.handlers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.ListHandlersResponse
 */
export const ListHandlersResponse = new ListHandlersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHandlerRequest$Type extends MessageType<GetHandlerRequest> {
    constructor() {
        super("awyes.GetHandlerRequest", [
            { no: 1, name: "handler", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetHandlerRequest>): GetHandlerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetHandlerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHandlerRequest): GetHandlerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string handler */ 1:
                    message.handler = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHandlerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string handler = 1; */
        if (message.handler !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.handler);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.GetHandlerRequest
 */
export const GetHandlerRequest = new GetHandlerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHandlerResponse$Type extends MessageType<GetHandlerResponse> {
    constructor() {
        super("awyes.GetHandlerResponse", [
            { no: 1, name: "handler", kind: "message", T: () => Handler }
        ]);
    }
    create(value?: PartialMessage<GetHandlerResponse>): GetHandlerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetHandlerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHandlerResponse): GetHandlerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional awyes.Handler handler */ 1:
                    message.handler = Handler.internalBinaryRead(reader, reader.uint32(), options, message.handler);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHandlerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional awyes.Handler handler = 1; */
        if (message.handler)
            Handler.internalBinaryWrite(message.handler, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.GetHandlerResponse
 */
export const GetHandlerResponse = new GetHandlerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterRouteRequest$Type extends MessageType<RegisterRouteRequest> {
    constructor() {
        super("awyes.RegisterRouteRequest", [
            { no: 1, name: "route", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterRouteRequest>): RegisterRouteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterRouteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterRouteRequest): RegisterRouteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string route */ 1:
                    message.route = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterRouteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string route = 1; */
        if (message.route !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.route);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.RegisterRouteRequest
 */
export const RegisterRouteRequest = new RegisterRouteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterRouteResponse$Type extends MessageType<RegisterRouteResponse> {
    constructor() {
        super("awyes.RegisterRouteResponse", []);
    }
    create(value?: PartialMessage<RegisterRouteResponse>): RegisterRouteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterRouteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterRouteResponse): RegisterRouteResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterRouteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.RegisterRouteResponse
 */
export const RegisterRouteResponse = new RegisterRouteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRoutesRequest$Type extends MessageType<ListRoutesRequest> {
    constructor() {
        super("awyes.ListRoutesRequest", []);
    }
    create(value?: PartialMessage<ListRoutesRequest>): ListRoutesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListRoutesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListRoutesRequest): ListRoutesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListRoutesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.ListRoutesRequest
 */
export const ListRoutesRequest = new ListRoutesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRoutesResponse$Type extends MessageType<ListRoutesResponse> {
    constructor() {
        super("awyes.ListRoutesResponse", [
            { no: 1, name: "routes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Route }
        ]);
    }
    create(value?: PartialMessage<ListRoutesResponse>): ListRoutesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.routes = [];
        if (value !== undefined)
            reflectionMergePartial<ListRoutesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListRoutesResponse): ListRoutesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated awyes.Route routes */ 1:
                    message.routes.push(Route.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListRoutesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated awyes.Route routes = 1; */
        for (let i = 0; i < message.routes.length; i++)
            Route.internalBinaryWrite(message.routes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.ListRoutesResponse
 */
export const ListRoutesResponse = new ListRoutesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRouteRequest$Type extends MessageType<GetRouteRequest> {
    constructor() {
        super("awyes.GetRouteRequest", [
            { no: 1, name: "route", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<GetRouteRequest>): GetRouteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetRouteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRouteRequest): GetRouteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string route */ 1:
                    message.route = reader.string();
                    break;
                case /* optional int64 version */ 2:
                    message.version = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRouteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string route = 1; */
        if (message.route !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.route);
        /* optional int64 version = 2; */
        if (message.version !== undefined)
            writer.tag(2, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.GetRouteRequest
 */
export const GetRouteRequest = new GetRouteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRouteResponse$Type extends MessageType<GetRouteResponse> {
    constructor() {
        super("awyes.GetRouteResponse", [
            { no: 1, name: "route", kind: "message", T: () => Route }
        ]);
    }
    create(value?: PartialMessage<GetRouteResponse>): GetRouteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetRouteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRouteResponse): GetRouteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional awyes.Route route */ 1:
                    message.route = Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRouteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional awyes.Route route = 1; */
        if (message.route)
            Route.internalBinaryWrite(message.route, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.GetRouteResponse
 */
export const GetRouteResponse = new GetRouteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartTripRequest$Type extends MessageType<StartTripRequest> {
    constructor() {
        super("awyes.StartTripRequest", [
            { no: 1, name: "route", kind: "message", T: () => Route },
            { no: 2, name: "entity", kind: "message", T: () => Entity },
            { no: 3, name: "start", kind: "message", T: () => Position },
            { no: 4, name: "state", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<StartTripRequest>): StartTripRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = {};
        if (value !== undefined)
            reflectionMergePartial<StartTripRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartTripRequest): StartTripRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional awyes.Route route */ 1:
                    message.route = Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                case /* optional awyes.Entity entity */ 2:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* optional awyes.Position start */ 3:
                    message.start = Position.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* map<string, google.protobuf.Value> state */ 4:
                    this.binaryReadMap4(message.state, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: StartTripRequest["state"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StartTripRequest["state"] | undefined, val: StartTripRequest["state"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field awyes.StartTripRequest.state");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: StartTripRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional awyes.Route route = 1; */
        if (message.route)
            Route.internalBinaryWrite(message.route, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional awyes.Entity entity = 2; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional awyes.Position start = 3; */
        if (message.start)
            Position.internalBinaryWrite(message.start, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Value> state = 4; */
        for (let k of globalThis.Object.keys(message.state)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.state[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.StartTripRequest
 */
export const StartTripRequest = new StartTripRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartTripResponse$Type extends MessageType<StartTripResponse> {
    constructor() {
        super("awyes.StartTripResponse", [
            { no: 1, name: "trip", kind: "message", T: () => Trip }
        ]);
    }
    create(value?: PartialMessage<StartTripResponse>): StartTripResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartTripResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartTripResponse): StartTripResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional awyes.Trip trip */ 1:
                    message.trip = Trip.internalBinaryRead(reader, reader.uint32(), options, message.trip);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartTripResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional awyes.Trip trip = 1; */
        if (message.trip)
            Trip.internalBinaryWrite(message.trip, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.StartTripResponse
 */
export const StartTripResponse = new StartTripResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchTripRequest$Type extends MessageType<WatchTripRequest> {
    constructor() {
        super("awyes.WatchTripRequest", [
            { no: 1, name: "trip", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WatchTripRequest>): WatchTripRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WatchTripRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchTripRequest): WatchTripRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string trip */ 1:
                    message.trip = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchTripRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string trip = 1; */
        if (message.trip !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.trip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.WatchTripRequest
 */
export const WatchTripRequest = new WatchTripRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTripsRequest$Type extends MessageType<ListTripsRequest> {
    constructor() {
        super("awyes.ListTripsRequest", [
            { no: 1, name: "entity", kind: "message", T: () => Entity }
        ]);
    }
    create(value?: PartialMessage<ListTripsRequest>): ListTripsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListTripsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTripsRequest): ListTripsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional awyes.Entity entity */ 1:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTripsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional awyes.Entity entity = 1; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.ListTripsRequest
 */
export const ListTripsRequest = new ListTripsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTripsResponse$Type extends MessageType<ListTripsResponse> {
    constructor() {
        super("awyes.ListTripsResponse", [
            { no: 1, name: "trips", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Trip }
        ]);
    }
    create(value?: PartialMessage<ListTripsResponse>): ListTripsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trips = [];
        if (value !== undefined)
            reflectionMergePartial<ListTripsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTripsResponse): ListTripsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated awyes.Trip trips */ 1:
                    message.trips.push(Trip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTripsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated awyes.Trip trips = 1; */
        for (let i = 0; i < message.trips.length; i++)
            Trip.internalBinaryWrite(message.trips[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.ListTripsResponse
 */
export const ListTripsResponse = new ListTripsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTripRequest$Type extends MessageType<GetTripRequest> {
    constructor() {
        super("awyes.GetTripRequest", [
            { no: 1, name: "trip", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTripRequest>): GetTripRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTripRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTripRequest): GetTripRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string trip */ 1:
                    message.trip = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTripRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string trip = 1; */
        if (message.trip !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.trip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.GetTripRequest
 */
export const GetTripRequest = new GetTripRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTripResponse$Type extends MessageType<GetTripResponse> {
    constructor() {
        super("awyes.GetTripResponse", [
            { no: 1, name: "trip", kind: "message", T: () => Trip }
        ]);
    }
    create(value?: PartialMessage<GetTripResponse>): GetTripResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTripResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTripResponse): GetTripResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional awyes.Trip trip */ 1:
                    message.trip = Trip.internalBinaryRead(reader, reader.uint32(), options, message.trip);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTripResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional awyes.Trip trip = 1; */
        if (message.trip)
            Trip.internalBinaryWrite(message.trip, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.GetTripResponse
 */
export const GetTripResponse = new GetTripResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchRequest$Type extends MessageType<SearchRequest> {
    constructor() {
        super("awyes.SearchRequest", [
            { no: 1, name: "query", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SearchRequest>): SearchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SearchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchRequest): SearchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string query */ 1:
                    message.query = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string query = 1; */
        if (message.query !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.SearchRequest
 */
export const SearchRequest = new SearchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchResponse$Type extends MessageType<SearchResponse> {
    constructor() {
        super("awyes.SearchResponse", [
            { no: 1, name: "routes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Route },
            { no: 2, name: "entities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity },
            { no: 3, name: "handlers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Handler }
        ]);
    }
    create(value?: PartialMessage<SearchResponse>): SearchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.routes = [];
        message.entities = [];
        message.handlers = [];
        if (value !== undefined)
            reflectionMergePartial<SearchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchResponse): SearchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated awyes.Route routes */ 1:
                    message.routes.push(Route.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated awyes.Entity entities */ 2:
                    message.entities.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated awyes.Handler handlers */ 3:
                    message.handlers.push(Handler.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated awyes.Route routes = 1; */
        for (let i = 0; i < message.routes.length; i++)
            Route.internalBinaryWrite(message.routes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated awyes.Entity entities = 2; */
        for (let i = 0; i < message.entities.length; i++)
            Entity.internalBinaryWrite(message.entities[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated awyes.Handler handlers = 3; */
        for (let i = 0; i < message.handlers.length; i++)
            Handler.internalBinaryWrite(message.handlers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message awyes.SearchResponse
 */
export const SearchResponse = new SearchResponse$Type();
/**
 * @generated ServiceType for protobuf service awyes.Awyes
 */
export const Awyes = new ServiceType("awyes.Awyes", [
    { name: "RegisterHandler", options: {}, I: RegisterHandlerRequest, O: RegisterHandlerResponse },
    { name: "ListHandlers", options: {}, I: ListHandlersRequest, O: ListHandlersResponse },
    { name: "GetHandler", options: {}, I: GetHandlerRequest, O: GetHandlerResponse },
    { name: "RegisterRoute", options: {}, I: RegisterRouteRequest, O: RegisterRouteResponse },
    { name: "ListRoutes", options: {}, I: ListRoutesRequest, O: ListRoutesResponse },
    { name: "GetRoute", options: {}, I: GetRouteRequest, O: GetRouteResponse },
    { name: "StartTrip", options: {}, I: StartTripRequest, O: StartTripResponse },
    { name: "WatchTrip", serverStreaming: true, options: {}, I: WatchTripRequest, O: Event },
    { name: "ListTrips", options: {}, I: ListTripsRequest, O: ListTripsResponse },
    { name: "GetTrip", options: {}, I: GetTripRequest, O: GetTripResponse },
    { name: "ListEvents", options: {}, I: ListEventsRequest, O: ListEventsResponse },
    { name: "Search", options: {}, I: SearchRequest, O: SearchResponse },
    { name: "RunNodeAndWait", serverStreaming: true, clientStreaming: true, options: {}, I: Event, O: Event }
]);
